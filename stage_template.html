<html>
    <head>
        <link rel="preconnect" href="https://rsms.me/" />
        <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
        <link rel="stylesheet" href="/style.css" />
        <script src="https://unpkg.com/function-plot/dist/function-plot.js"></script>
        <title>Stage STAGE_ID: STAGE_TITLE | EVENT_TITLE | Virtual Broomwagon</title>
    </head>
    <body>
        <header>
            <h1><a href="/">Virtual Broomwagon</a></h1>
            <h2><a href="..">EVENT_TITLE</a></h2>
            <h3><a>&lt;---</a> Stage STAGE_ID: STAGE_TITLE <a>---&gt;</a></h3>
            <p>STAGE_DATE</p>
            <p>STAGE_LENGTHkm • STAGE_TYPE • Coefficient STAGE_COEFFICIENT</p>
        </header>
        <div id="graphContainer" class="">
        <div id="speedButton">Cut vs Speed</div>
        <div id="timeButton">Cut vs Time</div>
        <div id="speedGraph"></div>
        <div id="timeGraph"></div>
        </div>

        <section>
            <label for="duration">Time elapsed:</label>
            <input id="duration" name="duration" class="html-duration-picker" data-duration-min="00:10:00" data-duration="04:00:00" />
            <label for="distance">Distance to finish:</label>
            <input id="distance" name="distance" type="number" step="0.1" value="0" min="0" max="STAGE_LENGTH" />
            <p>Loading...</p>
        </section>

        <table>
            <thead>
                <th><object data="/sprites/broom.svg"></object></th>
                <th>Location</th>
                <th><span title="km from start">S-></span><br /><span title="km to finish">->F</span></th>
                <!-- <th>SPEED_HIGH</th>
                <th>SPEED_MEDIUM</th>
                <th>SPEED_LOW</th> -->
            </thead>
            <!-- <tr>
                <td>
                    <object data="/sprites/depart_real.svg"></object>
                </td>
                <td>Atripalda (after 9km)</td>
                <td>0.0<br>171.0</td>
                <td>0h00'00"<br>+ 00'00"</td>
                <td>0h00'00"<br>+ 00'00"</td>
                <td>0h00'00"<br>+ 00'00"</td>
            </tr> -->
        </table>

        <script src="https://cdn.jsdelivr.net/npm/html-duration-picker@latest/dist/html-duration-picker.min.js"></script>

        <script>
            function stagemonolith(coefficient, distance, rounding, range) {

                function convertRemToPixels(rem) {
                    return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
                }

                let contentsBounds = document.getElementById("speedGraph").getBoundingClientRect().width || document.getElementById("timeGraph").getBoundingClientRect().width
                let width = 1920
                let height = 1080
                let ratio = (contentsBounds - convertRemToPixels(2)) / width
                width *= ratio
                height *= ratio

                functionPlot.globals.DEFAULT_WIDTH = width
                functionPlot.globals.DEFAULT_HEIGHT = height

                function converter (x, coefficient, distance, rounding = "") {
                    if (x < 0) {
                        return;
                    }

                    let baseline = 0

                    let stopper = false;

                    coefficient.forEach((value) => {

                        if (stopper) {
                            return;
                        }

                        if (value < 1) {
                            baseline = value
                        } else if (x <= value) {
                            stopper = true;
                        }
                    })

                    switch (rounding) {
                        case "ceil-s":
                            return Math.ceil(baseline * (distance / x) * 3600) / 60;
                            break;
                        case "ceil-m":
                            return Math.ceil(baseline * (distance / x) * 60);
                            break;
                        case "ceil-h":
                            return Math.ceil(baseline * (distance / x)) * 60;
                            break;
                        case "floor-s":
                            return Math.floor(baseline * (distance / x) * 3600) / 60;
                            break;
                        case "floor-m":
                            return Math.floor(baseline * (distance / x) * 60);
                            break;
                        case "floor-h":
                            return Math.floor(baseline * (distance / x)) * 60;
                            break;
                        case "round-s":
                            return Math.round(baseline * (distance / x) * 3600) / 60;
                            break;
                        case "round-m":
                            return Math.round(baseline * (distance / x) * 60);
                            break;
                        case "round-h":
                            return Math.round(baseline * (distance / x)) * 60;
                            break;
                        default:
                            return baseline * (distance / x) * 60;
                    }

                }

                function minmax (xes, coefficent, distance, rounding = "") {
                    let min = converter(xes[0], coefficient, distance, rounding)
                    let max = min
                    for (let index = xes[0]; index < xes[1]; index += 0.1) {
                        min = Math.min(min, converter(index, coefficient, distance, rounding))
                        max = Math.max(max, converter(index, coefficient, distance, rounding))
                    }

                    return [min - 1, max + 1]
                }

                function speedGraph (distance, coefficient, rounding = "") {
                    let target = document.getElementById("speedGraph");
                    function speedFormat (x) {
                        return `${x} km/h`
                    }
                    function overageFormat (y) {
                        return `+${Math.floor(y).toString().padStart(2, '0')}'${Math.floor((y * 60) % 60).toString().padStart(2, '0')}"`
                    }
                    let instance = functionPlot({
                        grid: true,
                        tip: {
                            xLine: true,
                            yLine: true,
                            renderer: function (x, y, index) {
                                x = x.toFixed(1);
                                x = speedFormat(x);

                                y = overageFormat(y);

                                return `${x}\n${y}`
                            }
                        },
                        yAxis: {
                            domain: minmax(range, coefficient, distance, rounding),
                            label: "Cutoff Time ->"
                        },
                        xAxis: {
                            domain: range,
                            label: "Finish Speed ->"
                        },
                        data: [
                            {
                                graphType: 'polyline',
                                color: 'red',
                                fn: (scope) => converter(scope.x, coefficient, distance, rounding)
                            }
                        ],
                        target
                    });

                    instance.meta.xAxis.tickFormat(speedFormat);
                    instance.meta.yAxis.tickFormat(overageFormat);
                    instance.meta.margin.left += 5;
                    instance.draw();

                    return instance;
                }

                var speedGraph = speedGraph(distance, coefficient, rounding);

                function timeToSpeed (time, distance) {
                    return distance / (time / 60)
                }

                function speedToTime (speed, distance) {
                    return (distance / speed) * 60
                }

                function ends (xes, distance) {
                    return [speedToTime(xes[0], distance), speedToTime(xes[1], distance)].reverse()
                }

                function timeGraph (distance, coefficient, rounding = "") {
                    let target = document.getElementById("timeGraph");
                    function speedFormat (x) {
                        return `${Math.floor(x / 60)}h${Math.floor(x % 60).toString().padStart(2, '0')}'${Math.floor((x * 60) % 60).toString().padStart(2, '0')}"`
                    }
                    function overageFormat (y) {
                        return `+${Math.floor(y).toString().padStart(2, '0')}'${Math.floor((y * 60) % 60).toString().padStart(2, '0')}"`
                    }
                    function timeFormat (x) {
                        return `${Math.floor(x / 60)}h${Math.floor(x % 60).toString().padStart(2, '0')}'`
                    }
                    let instance = functionPlot({
                        grid: true,
                        tip: {
                            xLine: true,
                            yLine: true,
                            renderer: function (x, y, index) {
                                x = x.toFixed(1);
                                x = speedFormat(x);

                                y = overageFormat(y);

                                return `${x}\n${y}`
                            }
                        },
                        yAxis: {
                            domain: minmax(range, coefficient, distance, rounding),
                            label: "Cutoff Time ->"
                        },
                        xAxis: {
                            domain: ends(range, distance),
                            label: "Finish Time ->"
                        },
                        data: [
                            {
                                graphType: 'polyline',
                                color: 'red',
                                fn: (scope) => converter(timeToSpeed(scope.x, distance), coefficient, distance, rounding)
                            }
                        ],
                        target
                    });

                    instance.meta.xAxis.tickFormat(timeFormat);
                    instance.meta.yAxis.tickFormat(overageFormat);
                    instance.meta.margin.left += 5;
                    instance.draw();

                    return instance;
                }

                var timeGraph = timeGraph(distance, coefficient, rounding);

                document.getElementById("speedButton").addEventListener("click", (e) => document.getElementById("graphContainer").classList.toggle("timeSwitch"));

                document.getElementById("timeButton").addEventListener("click", (e) => document.getElementById("graphContainer").classList.toggle("timeSwitch"));

                function updateVirtual() {
                    realDistance = distance - document.getElementById("distance").value;

                    duration = document.getElementById("duration").value.split(":").map(Number);

                    duration = duration[0] * 60 + duration[1] + duration[2] / 60;

                    speed = timeToSpeed(duration, realDistance).toFixed(1);

                    if (realDistance == distance) {
                        broomwagon = converter(speed, coefficient, distance, rounding);
                    } else {
                        broomwagon = converter(speed, coefficient, distance, rounding) * (realDistance / distance);
                    }

                    document.querySelector("section p").innerHTML = `${speed} km/h • Virtual broomwagon: + ${Math.floor(broomwagon).toString().padStart(2, '0')}'${Math.floor((broomwagon * 60) % 60).toString().padStart(2, '0')}"`
                }

                window.addEventListener('load', function () {
                    document.getElementById("distance").addEventListener("change", () => updateVirtual())

                    document.getElementById("duration").addEventListener("change", () => updateVirtual())

                    updateVirtual()
                })

            }

            stagemonolith(STAGE_COEFFICIENT_LIST, STAGE_LENGTH, "EVENT_ROUNDING", STAGE_RANGE);
        </script>

        <footer>
            <p>A First Exit Production | CURRENT_YEAR</p>
            <p>Licensed under <a href="https://github.com/Tantusar/virtual-broomwagon/blob/main/LICENSE">CC0 1.0 Universal</a>.</p>
        </footer>

    </body>
</html>